# 오브젝트 - 04 설계 품질과 트레이드오프

> 객체지향에는 행동, 책임이 중요한데, 이번장에선 상태를 중심으로 설계하는 데이터 중심 프로그램을 살펴보고 책임중심 설계와 비교한다.



### 01_데이터 중심의 영화 예매 시스템

데이터 중심 관점에서의 객체의 의미 - 데이터를 조작하는 데 필요한 오퍼레이션
책임 중심관점에서의 객체의 의미 - 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관

여기서 부터는 데이터 중심 설계

---

#### 데이터를 준비하자

각 객체가 의미를 가지는데 필요한 데이터를 먼저 생각하고, 나중에 객체간 협력을 고민한다. 마치 Table과. 같다. 



#### 영화를 예매하자

영화를 예매하는 클래스에 대한 내용을 책에서는 이야기 했다.

```
데이터 중심 설계에서는 객체는 자율적으로 처리하는 존재이기 보다는 데이터 저장소 느낌이다.
```



### 02_설계 트레이드오프

> 데이터 중심설계와 책임 중심설계를 비교하기 위해 캡슐화, 응집도, 결합도를 이용해서 비교한다.

#### 캡슐화

어떤걸 공개하고, 숨길것인지 결정하여, 변경의 여파를 최소화 시키는 것이 캡슐화의 목적이다.



#### 응집도와 결합도

응집도와 결합도는 캡슐화와 연관되어 있다.

응집도란? 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도라고 설명할 수 있다. 응집도가 높다면 변경이 일어 났을때, 하나의 모듈만 수정하면된다. 

결합도란? 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도. 하나 바뀌면 다른 모듈도 다 바뀌어야 하는 상태를 말한다.

```
응집도와 결합도를 헷갈릴 수 있다. 응집도가 낮다는 의미는 하나의 변경사항이 있을때, 이를 반영하기 위해 여러 모듈을 살펴야 하는 경우다.
결합도가 높다는 의미는 변경사항 하나를 반영하면, 그에 영향을 받는 모듈이 많음을 의미한다.
```



### 03_데이터 중심의 영화 예매 시스템의 문제점

> 캡슐화 위반, 높은 결합도, 낮은 응집도

1. 내부 구현을 인터페이스의 일부로 만든 점 - getter, setter를 이용해서 내부 상태를 인터페이스의 일부로 만들었다.



#### 캡슐화 위반

- getter, setter는 외부에 인스턴스 변수를 노출 시킨다. ( 외부에서 인스턴스 변수를 알아야 한다 ) 
  - 이와 같이 접근자에 의존하는 방식을 추측에 의한 설계라고 한다.
  - 이 이유는 협력을 먼저 생각하지 않고, "객체가 어디에 쓰일 지 모르니 일단 접근자를 만들어 놓자~"라는 마인드
- 객체에게 중요한 점은 상태가 아니라 책임이다. 접근자를 두어 책임이 아니라 상태를 외부에서 볼 수 있게 한다는 것은 데이터 중심 설계를 의미한다. 



#### 높은 결합도

> 데이터 중심설계의 영화 예매 시스템은 ReservationAgency라는 객체가 있어, Screening, Movie, DiscoutCondition 각 객체에서 필요한 정보를 모두 가져온다. 그리고 결과를 조합하여, 요청에 응답한다.

ReservationAgency는 각 객체들의 접근자를 이용해서 데이터를 가져온다. 하지만, 접근자를 사용하게 되면, 객체내의 인스턴스 변수가 바뀔경우 접근자도 바뀌어야 한다. 그에 영향을 받는 ReservationAgency도 바뀌어야 한다.

제어로직을 가진 제어 객체(ReservationAgency)와 모든 데이터 객체가 강한 결합을 가지게 된다.



#### 낮은 응집도

응집도가 낮다는 것은 하나를 수정하기 위해 그 해당클래스 하나만 보는 것이 아니라, 다른 클래스도 확인해야 한다. 

```
예를 들면, 인스턴스 변수를 수정할때 그 해당 클래스만 수정하는 것이 아니라 외부에서 호출한 접근자도 수정해야 한다. 단일 책임의 원칙은 응집도를 높히기 위한 원칙이다.
```



### 04_자율적인 객체를 향해

#### 캡슐화를 지켜라

객체는 외부에 어떤 데이터를 가지고 있는지 노출하면 안된다. 

- 내부데이터 변경시 외부도 영향을 받고 그 나비효과가 상당하다!!!



#### 스스로 자신의 데이터를 책임지는 객체

> 여기선 데이터 중심설계로 된 영화 예매시스템을 약간 수정한다.

설계시 포함하는 데이터 뿐 아니라 수행해야 하는 operation도 고민해야 한다.(operation이 더 중요)



### 05_하지만 여전히 부족하다

stay hungry, stay foolish

#### 캡슐화 위반

캡슐화는 변경될 수 있는 어떤것도 감추는 것이다. 위의 개선된 코드에서 getter, setter는 사용하지 않았지만, 파라미터로 메소드로 객체의 데이터를 외부에 노출시킨다. 이는 객체 인스턴스변수가 바뀌면 파장이 크다.

캡슐화의 진정한 의미는 변경될 수 있는 어떤것도 감추는 것이다.



#### 높은 결합도

캡슐화의 위바느올 내부 데이터가 바뀌면, 다른 객체에게 영향을 준다.



#### 낮은 응집도

응집도가 낮다는 것은 2가지를 의미한다.

1. 하나의 변경사항을 하나의 모듈 내에서 처리하지 못한다.

2. 하나의 변경사항을 위해 여러 곳을 동시에 수정해야 한다.

   - 하나의 변경사항이 여러 모듈에 영향을 준다.(X 결합도..??)

   

### 06_데이터 중심 설계의 문제점

#### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

너무 이른시기에 데이터에 대해 고민하고, 그 결과가 인터페이스에 영향을 미친다.



#### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

내부를 먼저 생각하기 때문에 외부로 내부가 드러나고, 의존성을 갖게 되고 변화가 어려운 설계가 탄생한다.













